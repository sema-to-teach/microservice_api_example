Проект, который мы описывали, является code-first (код-ориентированным) подходом, а не contract-first.

Отличие между code-first и contract-first подходами
Code-first:

В подходе code-first (код-ориентированный) разработчик сначала пишет код (например, модели, схемы данных, маршруты API и т. д.). После этого на основе кода генерируются другие артефакты, такие как документация API (например, с помощью OpenAPI), миграции для базы данных или схемы для интерфейсов.
В случае с FastAPI, как в нашем проекте, мы сначала пишем код, описывающий логику работы API, а затем FastAPI автоматически генерирует документацию (например, Swagger UI) и OpenAPI-схему.
Это подход, при котором API и его спецификации создаются непосредственно в процессе разработки и изменяются вместе с кодом.
Contract-first:

В подходе contract-first (контракт-ориентированном) сначала разрабатывается спецификация API, которая описывает все доступные эндпоинты, параметры и типы данных (например, в формате OpenAPI или WSDL). Этот контракт затем используется для генерации кода серверов и клиентов.
В этом случае разработчик сначала определяет контракт (например, с использованием OpenAPI), а потом уже пишет код, который будет удовлетворять этому контракту. Это помогает более четко разделить процесс проектирования API и его реализации.
Почему наш проект — code-first?
Генерация документации: В проекте мы используем FastAPI, который автоматически генерирует документацию API (в том числе Swagger UI) на основе аннотаций Python-кода, таких как типы данных в маршрутах и моделях.

Модели и схемы данных: Мы сначала создаем модели SQLAlchemy (например, User, Order), которые описывают структуру базы данных. На основе этих моделей затем создаются миграции с помощью Alembic.

API-эндпоинты: Мы создаем API-эндпоинты (например, для получения пользователей или создания заказов) в коде, используя декораторы и зависимости FastAPI. Спецификация этих эндпоинтов (например, HTTP-методы, пути) определяется непосредственно в коде.

Что можно изменить, чтобы сделать проект contract-first?
Если бы мы применяли contract-first подход, то вначале мы бы создали контракт API (например, в формате OpenAPI или Swagger), который описывает все маршруты, параметры и схемы данных. Этот контракт затем можно было бы использовать для генерации серверного кода.

Пример шагов для contract-first:

Создать файл спецификации OpenAPI (например, api_spec.yaml или api_spec.json).
Сгенерировать сервер с помощью инструментов, таких как Swagger Codegen или OpenAPI Generator, которые могут на основе спецификации генерировать серверный код и модели.
Реализовать логику обработки запросов в сгенерированных файлах или дополнить их.
Такой подход часто используется для обеспечения согласованности между клиентами и серверами в крупных распределенных системах или при интеграции с внешними сервисами, где важно строго следовать заранее определенному контракту API.

